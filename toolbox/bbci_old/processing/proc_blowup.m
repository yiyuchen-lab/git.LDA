function [epo_out recombIvals] = proc_blowup(epo,varargin)
% PROC_BLOWUP - artificially increase the number of data points in epo by
% recombining existing data points (artifical data generation, ADG).
%
%Synopsis:
%   EPO_OUT = proc_blowup(EPO, <OPT>)
%
%Arguments:
%   EPO: STRUCT - epo struct of EEG data containing data in .x
%                 and labels in .y
%   OPT: PROPLIST - Structure or property/value list of optional properties:
%     'classList' - cell array containing names (STRINGS) of N classes, which are
%                   represented in EPO and shall be increased in size.
%                   Default: empty.
%     'classSizes' - DOUBLE [1xN] vector describing for N classes of
%                     CLASSLIST, how many data points of that class shall be returned.
%                     Default: all classes are increased to the size of the
%                     largest class contained in EPO.
%     'numDivisions' - INT number of equal-sized (up to rounding of samples) intervals.
%                      Each original epoch contained in EPO is broken up
%                      into these intervals.
%                      Observing the temporal order of these pieces and
%                      their class-memberships, artifical new epochs are
%                      generated by randomly combining the original pieces.
%                      Default: 5
%
%Returns:
%   EPO_OUT: STRUCT - enlarged epo struct of EEG data containing data in .x
%                     and labels in .y
%   RECOMB_IVALS: FLOAT [Mx2] - interval borders chosen to recombine
%                               articial trials
%
%
%Description:
%   PROC_BLOWUP is used to increase the number of data points of an EPO
%   structure, by artificially generating "new" data points from a temporal
%   re-combination of existing data points of the same class. Original data points are
%   preserved, while artifically generated data points are concatenated to
%   the original ones. Data points are created separately for each class, and the class labels
%   in epo_out.y are generated accordingly.
%   For motor imagery data, this procedure was proposed by Fabien Lotte as
%   artificial data generation (ADG). He showed, that the ADG
%   performed similar to shrinkage regularization with LDA classfication.
%
% References:
%   Fabien Lotte: Generating Artificial EEG Signals To Reduce BCI
%   Calibration Time. 5th International Brain-Computer Interface Workshop,
%   p.176-179, 2011.
%   hal.inria.fr/docs/00/59/93/25/PDF/bciworkshop2011.pdf
%
%
% Example:
%
%   opt_blowup.classList = {'target','non-target'};
%   opt_blowup.classSizes = [500 500];
%   opt_blowup.numDivisions = 10;
%
%   large_epo = proc_blowup(small_epo, opt_blowup);
%
% See also XVALIDATION

% ToDo:
%   Interval borders are not defined nicely, as overlaps between
%   consecutive intervals may appear (especially for large number of
%   intervals!)
%
%
% Michael Tangermann 2012_11_20

opt= propertylist2struct(varargin{:});
if isfield(opt, 'isPropertyStruct')
    opt = remove_field(opt, 'isPropertyStruct');
end
[opt, isdefault]= ...
    set_defaults(opt, ...
    'classList', epo.className, ...
    'classSizes', repmat(max(sum(epo.y')),1,size(epo.className,2)), ...
    'numDivisions', 5);

%% Sanity checking and conversions

% Dimensionality of labels
if size(opt.classList,2) ~= length(opt.classSizes)
    error('Number of classes and number of sizes must match.');
end

% Check for format of opts
if ~iscellstr(opt.classList)
    opt.classList = {opt.classList}
    if ~iscellstr(opt.classList)
        error('Wrong format for opt.classList');
    end
end
if ~isnumeric(opt.classSizes)
    error('Wrong format for opt.classSizes');
end
if opt.numDivisions > size(epo.x,1)
    error(['numDivisions exceeds number of samples per epoch of ' num2str(size(epo.x,1))]);
end
if ~isnumeric(opt.numDivisions) || opt.numDivisions<1
    error('Wrong format for opt.numDivisions');
end
if opt.numDivisions<2
    warning('Setting numDivisions to less than 2 does not generate new trials, but only copies exisiting ones. Use larger numDivisions instead.');
end
if opt.numDivisions < size(epo.x,1)
    warning('Setting numDivisions to a large number might lead to unbalanced intervals. Check output!');
end




% Check: is every class name, which is mentionend in the opts also contained in epo?
collect=[];
for i=1:size(opt.classList,2)
    tmp=strcmp(epo.className,opt.classList(1,i));
    collect=[collect; tmp];
    if sum(tmp) ~= 1
        error(['Class name ' opt.classList{1,i} ' of opt.classList was not found in epo!']);
    end
end
if max(sum(collect))>1
    error(['Some classes appear more than once!']);
end

% Now re-order the opt.classSizes to match the order in epo.classNames
new_classList=epo.className; % finally, opt will receive the same order of class names as in epo!
new_classSizes=zeros(1,size(epo.className,2));
for i=1:size(epo.className,2)
    pos=find(collect(:,i));
    % if there is no entry for this className, leave it zero
    if pos>0
        new_classSizes(i)=opt.classSizes(pos);
    end
end

% Everything should be clean now, so write values to opt!
opt.classList=new_classList;
opt.classSizes=new_classSizes;


% Prepare output
epo_out = epo;

%% Blow up the data

% Calculate the size of time intervals (pieces)
ivalSize = (size(epo.x,1)-1) / opt.numDivisions;
ivals = [1 ivalSize+1];
ivals = repmat(ivals,opt.numDivisions,1);
ivals = ivals +  repmat(([0:opt.numDivisions-1]*ivalSize)',1,2);
ivals = round(ivals);
% ToDo: check for overlaping samples of subsequent intervals and correct them without generating holes in the
% interval coverage

% Make sure the extremes are set correctly:
ivals(1,1) = 1;
ivals(end,2) = size(epo.x,1);
recombIvals = ivals

for iCl = 1:size(opt.classList,2) % For each class
    % determine necessary number of new data points
    
    idxExisting = find(epo.y(iCl,:)');
    numExisting = size(idxExisting,1);
    numMissing = opt.classSizes(iCl) - numExisting;
    if numMissing>0
        % dummy x and y
        x_tmp = zeros(size(epo.x,1),size(epo.x,2),numMissing);
        y_tmp = zeros(size(epo.y,1),numMissing);
        % Fill class labels for the current class
        y_tmp(strmatch(opt.classList(iCl),epo.className,'exact'),1:end)=1;
        
        % create random numbers to select pieces of existing epochs
        selEx = randi(numExisting,numMissing,opt.numDivisions);
        
        for iData = 1:numMissing;
            % Fill with pieces of old data!
            for iDivisions=1:opt.numDivisions
                % go through intervals resp. divisions and copy data according
                % to random selection matrix selEx. Some samples might be
                % overwritten by consecutive entries, but this does no
                % matter by now...
                x_tmp(ivals(iDivisions,1):ivals(iDivisions,2),:,iData) = epo.x(ivals(iDivisions,1):ivals(iDivisions,2),:,selEx(iData,iDivisions));
                %plot(squeeze(x_tmp(:,:,1))) ; figure(gcf)
            end
        end
        epo_out.x = cat(3, epo_out.x , x_tmp);
        epo_out.y = cat(2, epo_out.y , y_tmp);
        disp(['Enlargement of ' num2str(numMissing) ' data points for class:  ' opt.classList{iCl}]);
    else
        disp(['No enlargement necessary for class:  ' opt.classList{iCl}]);
    end
end

%% Cleanup fields, that have no meaning any more (the artificial data has
% no time stamp!) and return the enlarged epo

if isfield(epo_out,'indexedByEpochs')
    epo_out = rmfield(epo_out,'indexedByEpochs');
end
if isfield(epo_out,'time')
    epo_out = rmfield(epo_out,'time');
end

disp('Successfully created artificial data!');


